# Chapter 2. 객체지향 프로그래밍

## 객체지향 패러다임을 따라 구현하려면 어떻게 해야 할 것인가?

1. 어떤 객체들이 필요한지 고민한다.
   - 어떤 객체들이 어떤 상태와 행동을 갖는지 결정한다.
2. 객체를 기능을 구현하기 위해 협력하는 공동체의 일원으로 바라본다.
   - 이를 통해 설계를 유연하고 확장 가능하게 할 수 있다.

## 도메인

- 문제를 해결하기 위해 사용자가 애플리케이션에서 정의하는 분야
- 객체지향 패러다임이 강력한 이유는, 요구사항을 분석하는 초기 단계부터 애플리케이션을 구현하는 마지막 단계까지
  객체라는 동일한 추상화 기법을 사용할 수 있음
  - 요구사항에서 도출될 수 있는 도메인을 구성하는 개념들이,
  - 애플리케이션의 객체와 클래스로 매끄럽게 연결될 수 있음

## 객체의 자율성

- 객체가 갖는 주요한 두 가지 사실
  - 객체는 상태와 행동을 함께 가지는 복합적인 존재이다.
  - 객체는 스스로 판단하고 행동하는 자율적인 존재이다.

### 캡슐화

- 객체라는 단위 안에, 데이터와 기능을 한 덩어리로 묶는 것
- 캡슐화를 통해 문제 영역의 아이디어를 적절하게 표현

### 접근 제어

- 객체 외부에서 특정 객체에 대해 접근 가능한 부분, 접근 불가능한 부분을 구분

### 인터페이스와 구현의 분리

- 객체는 캡슐화와 접근 제어를 바탕으로 다음과 같이 두 부분으로 나뉨
  - 퍼블릭 인터페이스(public interface): 외부에서 접근 가능한 부분
  - 구현(implementation): 외부에서는 접근이 불가하고 내부에서만 접근 가능한 부분
- 객체의 '상태'나 구현에 해당하는 것들은 숨기고, 외부에 공개하는 것은 인터페이스에 해당하는 '행동'
- 객체의 외부와 내부를 구분할 경우 다음과 같은 이점이 존재
  - 객체의 행동을 사용하는 측에서는 객체를 사용하기 위해 알아야 할 지식의 양이 줄어듦
  - 객체를 작성하는 측에서는 구현의 내용을 자유롭게 변경할 수 있음
- 설계가 필요한 이유는 변경을 효과적으로 관리하기 위함!

### 협력

- 객체는 외부에 공개하는 퍼블릭 인터페이스를 통해서만 내부 상태에 접근하도록 허용
- 객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것
  - 다른 객체는 해당 객체의 인터페이스에 공개된 행동을 수행하도록 요청(request)
  - 요청을 받은 객체는 각자의 방법에 따라 요청을 처리한 후 응답(response)
- 메시지를 수신한 객체는 자신만의 방법인 메서드(method)를 통해 메시지를 처리할 방법을 결정

## 올바른 상태를 가진 객체를 생성하려면?

- 생성자에 전달되는 인자들을 이용해 객체의 초기화에 필요한 정보를 전달하도록 강제함으로써
  올바른 상태를 가진 객체의 생성을 보장할 수 있음

## 상속과 다형성

### 템플릿 메서드 패턴 (Template Method Pattern)

- 부모 클래스에 기본적인 동작의 흐름을 구현하고,
  중간에 필요한 처리는 자식 클래스에게 위임하는 디자인 패턴

### 컴파일 시간 의존성 vs 실행 시간 의존성

- 코드의 의존성과 실행 시점의 의존성은 서로 다를 수 있음.

```java
public class Movie {
    public Money calculateMovieFee(Screening screening) {
        Money discountAmount = discountPolicy.calculateDiscountAmount(screening);
        return fee.minus(discountAmount);
    }
}
```

- calculateMovieFee에는 할인 정책을 결정하는 조건문이 없음에도 할인 정책을 선택할 수 있음.
- Movie를 생성할 때, 해당 할인 정책에 맞는 DiscountPolicy 클래스의 인스턴스를 전달하는 것이 가능

```java
Movie avatar = new Movie.Builder()
    .title("아바타")
    .runningTime(Duration.ofMinutes(120))
    .fee(Money.wons(10000))
    .discountPolicy(new DiscountAmountPolicy(Money.wons(800)), ...)
    .build();
```

- 코드의 의존성과 실행 시점의 의존성이 다른 설계를
  유연하고, 쉽게 재사용할 수 있으며, 확장 가능한 객체지향 설계라 할 수 있음
- 단, 설계가 유연해질수록 코드를 이해하고 디버깅하는 것은 어려워질 수 있음
  - 코드를 이해하기 위해 코드뿐만 아니라 객체를 생성하고 연결되는 부분도 알 수 있어야 하기 때문
- 무조건 유연한 설계도, 무조건 읽기 쉬운 코드도 정답은 아님. 모든 것은 트레이드오프의 산물!

### 다형성

- Movie는 협력하는 객체가 calculateDiscountAmount 메시지를 이해할 수만 있으면,
  그 객체가 어떤 클래스의 인스턴스인지는 상관하지 않음.
- Movie는 calculateDiscountAmount라는 동일한 메시지를 전송하지만,
  실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체가 어떤 객체인지에 따라 달라질 수 있음
- 다형적인 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 함.
  즉 인터페이스가 동일해야 함.
- 이처럼 메시지와 메서드를 실행 시점에 바인딩하는 것을
  지연 바인딩(Lazy Binding) 또는 동적 바인딩(Dynamic Binding)이라 지칭
  - cf. 실행할 함수나 프로시저를 컴파일 시점에 결정하는 것은
    초기 바인딩(Early Binding) 또는 정적 바인딩(Static Binding)이라 지칭

## 추상화의 유연성

- abstract class와 interface는, 자신을 extend하거나 implement한 클래스보다 '추상적'
  - abstract class와 interface에는 하위의 모든 클래스들이
    공통으로 가질 수 있는 인터페이스가 정의되기 때문

### 추상화의 장점

1. 추상화된 계층만 따로 떼어놓고 살펴봤을 때, 요구사항의 정책을 높은 수준에서 서술할 수 있음
   - 세부적인 구현 내용을 모두 직접 드러내지 않고도 상위 정책을 쉽고 간단하게 표현할 수 있음
   - 상위 정책을 기술하는 것은 애플리케이션의 기본적인 협력 흐름을 기술한다는 것을 의미.
2. 설계를 유연하게 가져갈 수 있음
   - 새로운 기능의 추가나 확장이 필요할 경우, 기존 구조를 수정하지 않고
     abstract class를 상속받거나 interface를 구현한 클래스를 추가하는 것만으로도
     기능을 쉽게 추가하거나 확장할 수 있음
   - 설계가 구체적인 상황에 결합되는 것을 방지할 수 있기 때문
   - 이는 컨텍스트 독립성(Context Independency)으라는 개념으로 지칭

## 합성

- 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함시킨 뒤,
  포함된 객체의 인터페이스에 정의된 메서드를 통해 코드를 재사용하는 방식

### 상속의 문제점

- 상속은 객체지향에서 코드를 재사용하기 위해 널리 사용되지만,
  다음의 두 관점에서 설계에 좋지 못한 영향을 끼칠 수 있음

1. 캡슐화를 위반
   - 부모 클래스의 구현이 자식 클래스에게 노출될 수 있음
   - 즉 자식 클래스가 부모 클래스에 강하게 결합되기 때문에,
     부모 클래스를 변경할 때 자식 클래스도 함께 변경될 확률이 높아짐
2. 설계가 유연해지지 못함
   - 부모 클래스와 자식 클래스 사이의 관계가 컴파일 시점에 결정되기 때문에,
     실행 시점에 객체의 종류를 변경하는 것이 불가능해짐

### 합성의 이점

- 연결되는 두 객체가 재사용되는 객체의 인터페이스만을 통해 약하게 결합되기 때문에,
  구현을 효과적으로 캡슐화할 수 있음
- 의존하는 인스턴스를 교체하는 것이 쉽기 때문에 설계가 유연해짐
- 다만 다형성을 위해 인터페이스를 재사용하는 경우에는 상속과 합성을
  적절히 조합해서 사용하는 것이 가장 이상적이라 할 수 있겠음
